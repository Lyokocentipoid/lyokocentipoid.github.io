<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portfoli de Lyokocentipoid</title>
  <link rel="stylesheet" href="/assets/css/style.css">
</head>
<body>

  <!-- Canvas per a les partícules (fons fix) -->
  <canvas id="particles-canvas"></canvas>

  <header>
    <img src="/assets/img/foto-perfil.jpg" alt="Foto de Lyokocentipoid" class="foto-rodona">
    <h1>Lyokocentipoid</h1>
    <p>Espai de projectes web</p>
  </header>

  <section id="projectes">
    <h2>Projectes educatius - Matemàtiques</h2>
    <a href="/geometria1eso/" class="projecte-card">
      <h3>Geometria de 1r ESO</h3>
      <p>Web de conceptes bàsics de geometria</p>
    </a>
    <!-- Afegeix més cards aquí quan tinguis més projectes -->
  </section>

  <script>
    const canvas = document.getElementById('particles-canvas');
    const ctx = canvas.getContext('2d');

    let particles = [];
    const NUM_PARTICLES = 80;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function randomBetween(a, b) {
      return a + Math.random() * (b - a);
    }

    class Particle {
      constructor() { this.reset(true); }

      reset(initial = false) {
        this.x = randomBetween(0, canvas.width);
        // Si és l'inici, distribueix per tota la pantalla; si no, reapareix per baix
        this.y = initial ? randomBetween(0, canvas.height) : canvas.height + 5;
        this.r = randomBetween(0.8, 2.5);
        this.speedX = randomBetween(-0.4, 0.4);
        this.speedY = randomBetween(-0.6, -1.8);  // velocitats variades cap amunt
        this.angle = randomBetween(0, Math.PI * 2);
        this.twinkleSpeed = randomBetween(0.01, 0.04);
      }

      update() {
        this.x += this.speedX;
        this.y += this.speedY;

        // Parpelleig suau amb sinus
        this.angle += this.twinkleSpeed;
        this.opacity = 0.3 + 0.7 * Math.abs(Math.sin(this.angle));

        if (this.y + this.r < 0) this.reset();
        if (this.x - this.r > canvas.width) this.x = -this.r;
        if (this.x + this.r < 0) this.x = canvas.width + this.r;
      }

      draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;

        // Resplendor exterior (glow)
        const glow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.r * 4);
        glow.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        glow.addColorStop(0.4, 'rgba(220, 240, 255, 0.4)');
        glow.addColorStop(1, 'rgba(255, 255, 255, 0)');

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r * 4, 0, Math.PI * 2);
        ctx.fillStyle = glow;
        ctx.fill();

        // Nucli brillant
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        ctx.fill();

        ctx.restore();
      }
    }

    for (let i = 0; i < NUM_PARTICLES; i++) particles.push(new Particle());

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      particles.forEach(p => { p.update(); p.draw(); });
      requestAnimationFrame(animate);
    }
    animate();
  </script>

</body>
</html>
